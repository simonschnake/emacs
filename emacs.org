-*- mode: org; fill-column: 78 -*-
#+TITLE: Emacs Configuration
#+AUTHOR: Simon Schnake
#+OPTIONS: toc:4 h:4

* Intro

This my emacs-config. It should be stable at the moment.
It is based on [[https://github.com/Kaali/vj-emacs-0x12][vj-emacs-0x12]].

Key features are:
- fast startup time
- ivy
- fast switching between dark and light theme with gtk also changing
- language-server-protocoll support (python)
- ob-ipython

** TODO Requirements

Here i will add all additional tools, you need for full usage

** Installation

Keep it simple. Clone as =~/.emacs.d= and

** TODO Things to add
- cdlatex in org-mode
- =C-h= as an alternative to Backspace
- =M-h= as an alternative to =M-BACK=
- proselint
- multiple-cursors
- bibliography managment
- good support fort editing org src parts without =C-'=
- ipython jupyter notebook handling to come
* Bootstrap Configuration
** Benchmark Emacs startup

It's easier to optimize Emacs startup time when I have some data
available. Time code borrowed from [[https://github.com/jwiegley/dot-emacs/blob/master/init.el][John Wiegley's init.el]]

#+BEGIN_SRC emacs-lisp
  (defconst emacs-start-time (current-time))

  (defun display-startup-echo-area-message ())

  (add-hook 'after-init-hook
            `(lambda ()
               (let ((elapsed
                      (float-time
                       (time-subtract (current-time) emacs-start-time))))
                 (message "Loading %s...done (%.3fs) [after-init]"
                          ,load-file-name elapsed))) t)
#+END_SRC

** Startup optimizations
*** Adjust GC in startup

Emacs garbage collector tries to use sane settings for an interactive
environment. It reduced throughput a bit. We can make Emacs start
faster by adjusting GC on startup and then fallback to interactive
settings.

#+BEGIN_SRC emacs-lisp
  (defvar original-gc-cons-threshold gc-cons-threshold)
  (defvar original-gc-cons-percentage gc-cons-percentage)

  (setq gc-cons-threshold 402653184
        gc-cons-percentage 0.6)

  (add-hook 'after-init-hook
            `(lambda () (setq gc-cons-threshold original-gc-cons-threshold
                              gc-cons-percentage original-gc-cons-percentage)) t)

#+END_SRC
*** Remove file handlers on startup

Make startup faster by removing all file handlers for the duration of
the startup. Should not affect initialization with my configuration.

#+BEGIN_SRC emacs-lisp
  (defvar file-name-handler-alist-old file-name-handler-alist)
  (setq file-name-handler-alist nil)
  (add-hook 'after-init-hook
            `(lambda () (setq file-name-handler-alist file-name-handler-alist-old)) t)
#+END_SRC
** Harden TLS

#+BEGIN_SRC emacs-lisp
  (require 'tls)
  (setq tls-checktrust t)
#+END_SRC

** Use custom file
Use a specific custom file instead of saving things in =init.el= which
is used to bootstrap =org-babel=.

#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file t)
#+END_SRC

** Setup package management

Setup package.el manually to speed up startup. Adapted from
[[https://github.com/gilbertw1/emacs-literate-starter/blob/master/emacs.org#emacs-initialization][emacs-literate-starter]] and [[https://github.com/nilcons/emacs-use-package-fast][emacs-use-package-fast]].

#+BEGIN_SRC emacs-lisp
  (eval-and-compile
    (setq load-prefer-newer t
          package-user-dir "~/.emacs.d/elpa"
          package--init-file-ensured t
          package-enable-at-startup nil)

    (unless (file-directory-p package-user-dir)
      (make-directory package-user-dir t))

    (eval-and-compile
      (setq load-path (append load-path (directory-files package-user-dir t "^[^.]" t))))

    ;; Add packages to info, required because we haven't run
    ;; package-initialize
    (with-eval-after-load "info"
      (info-initialize)
      (dolist (dir (directory-files package-user-dir))
        (let ((fdir (concat (file-name-as-directory package-user-dir) dir)))
          (unless (or (member dir '("." ".." "archives" "gnupg"))
                      (not (file-directory-p fdir))
                      (not (file-exists-p (concat (file-name-as-directory fdir) "dir"))))
            (add-to-list 'Info-directory-list fdir))))))
#+END_SRC

Initialize package.el and [[https://github.com/jwiegley/use-package][use-package]] only when compiling. But hook up
the initialization if =package-initialize= is called so that package.el
still works.

#+BEGIN_SRC emacs-lisp
  (defun vj--setup-package-el (&optional _)
    (require 'package)
    ;; Make package-installed-p only check the user package dir for org-mode
    ;; to make it skip the bundled org-mode.
    (defun vj--package-installed-p (orig-fn &rest args)
      (if (eq (car args) 'org)
          (if (file-expand-wildcards (concat package-user-dir "/org-[0-9]*")) t nil)
        (apply orig-fn args)))
    (advice-add 'package-installed-p :around #'vj--package-installed-p)

    (let* ((no-ssl (and (memq system-type '(windows-nt ms-dos))
                        (not (gnutls-available-p))))
           (proto (if no-ssl "http" "https")))
      (add-to-list 'package-archives (cons "melpa" (concat proto "://melpa.org/packages/")) t)
      (add-to-list 'package-archives (cons "org" (concat proto "://orgmode.org/elpa/")) t)
      (setq package-archive-priorities '(("org" . 3)
                                         ("melpa" . 2)
                                         ("gnu" . 1)))))

  (advice-add #'package-initialize :before #'vj--setup-package-el)

  (eval-when-compile
    (package-initialize)
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package)))

  ;; In init-file-debug mode, enable verbosity and statistics for use-package.
  (eval-and-compile
    (setq use-package-always-ensure t)
    (if init-file-debug
        (setq use-package-verbose t
              use-package-expand-minimally nil
              use-package-compute-statistics t)
      (setq use-package-verbose nil
            use-package-expand-minimally t
            use-package-compute-statistics nil)))

  (eval-when-compile
    (require 'use-package))
#+END_SRC

When running from byte compiled file, setup autoload for =use-package=
so it can be used seamlessly. It also does package-initialize after
load to make sure =package.el= is also initialized.

#+BEGIN_SRC emacs-lisp
  (unless (featurep 'use-package)
    (require 'package)
    (autoload 'use-package "use-package")
    (eval-after-load "use-package" #'package-initialize))
#+END_SRC

Add [[https://github.com/emacsmirror/diminish][diminish]] and bind-key support to =use-package=

#+BEGIN_SRC emacs-lisp
  (use-package diminish)
  (use-package bind-key)
  ; Requires here should speed up the boot
  (require 'diminish)
  (require 'bind-key)
#+END_SRC

* Global configuration
** Settings
*** Disable byte compile warnings
 Disable certain byte compiler warnings to cut down on the noise. This is a personal choice and can be removed
 if you would like to see any and all byte compiler warnings.

 #+BEGIN_SRC emacs-lisp
 (setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
 #+END_SRC

*** Personal stuff
    Pretty self explanatory: just setting some personal details about who's using Emacs.
    #+begin_src emacs-lisp
    (setq user-full-name "Simon Schnake"
          user-mail-address "schnake.simon@gmail.com")
    #+end_src

*** Deactivation
    Deactivation of functionality I don't tend to use:
    - Backup files
    - Autosaving
    - Start-up message
    - Audible bell
    #+begin_src emacs-lisp
    (setq
      make-backup-files nil
      auto-save-default nil
      inhibit-startup-message t
      ring-bell-function 'ignore)
    #+end_src
*** Hide stuff
    Hide various elements of the Emacs GUI:
    - toolbar
    - tooltips
    - scrollbar
    - menubar
    - blinking cursor
    #+begin_src emacs-lisp
      (dolist
          (mode
           '(tool-bar-mode
             tooltip-mode
             scroll-bar-mode
             menu-bar-mode
             blink-cursor-mode))
        (funcall mode 0))
    #+end_src

*** UTF-8
    Configure Emacs for full UTF-8 compatability
    #+begin_src emacs-lisp
    (set-charset-priority 'unicode)
    (setq locale-coding-system   'utf-8)
    (set-terminal-coding-system  'utf-8)
    (set-keyboard-coding-system  'utf-8)
    (set-selection-coding-system 'utf-8)
    (prefer-coding-system        'utf-8)
    (setq default-process-coding-system '(utf-8-unix . utf-8-unix))
    #+end_src

*** Global ~:ensure~ for ~use-package~ statements
    ~use-package~ has an ~:ensure~ keyword which dictates whether packages are installed or not.
    As most of my ~use-package~ configurations are for external packages, I set this to always ensure.
    Then, in cases where I don't want this to be true, I simply set ~:ensure nil~
    #+begin_src emacs-lisp
    (setq use-package-always-ensure t)
    #+end_src

*** Discard customizations
    Emacs has a comprehensive customization system that allows configuration changes interactively.
    Personally, I opt to ensure all the configuration I use for my environment is fully declarative.
    As such, the following configuration sets the ~custom-file~ to be a random temporary file created each time Emacs starts.
    This means any customizations made interactively are discarded entirely.
    #+begin_src emacs-lisp
    (setq custom-file (make-temp-file ""))
    #+end_src

*** Just use 'y' or 'n' instead of 'yes' or 'no'
    You'll find ~yes-or-no~ prompts coming up in Emacs a lot.
    I'd much rather just type ~y~ or ~n~ than ~yes~ or ~no~ every time...
    #+begin_src emacs-lisp
    (fset 'yes-or-no-p 'y-or-n-p)
    #+end_src

*** Follow symlinks in version control
    If there are any symlinks in version controlled repositories, follow them
    #+begin_src emacs-lisp
    (setq vc-follow-symlinks t)
    #+end_src

*** Configure FlySpell to use aspell
    I use ~aspell~, so this simply sets [[https://www.emacswiki.org/emacs/FlySpell][Flyspell]] to use it and passes a couple extra arguments
    #+begin_src emacs-lisp
    (setq ispell-program-name "aspell")
    (setq ispell-extra-args '("--sug-mode=ultra" "--lang=en_US"))
    #+end_src

*** Copy&Paste inside terminal
Enable terminal emacs to copy and paste from system clipboard
Note: this uses =C-c= before the usual =C-w=, =M-w= and =C-y=
From: https://stackoverflow.com/questions/64360/how-to-copy-text-from-emacs-to-another-application-on-linux
you need to install xsel
#+BEGIN_SRC emacs-lisp
(defun my-copy-to-xclipboard(arg)
  (interactive "P")
  (cond
   ((not (use-region-p))
    (message "Nothing to yank to X-clipboard"))
   ((and (not (display-graphic-p))
         (/= 0 (shell-command-on-region
                (region-beginning) (region-end) "xsel -i -b")))
    (message "Error: Is program `xsel' installed?"))
   (t
    (when (display-graphic-p)
      (call-interactively 'clipboard-kill-ring-save))
    (message "Yanked region to X-clipboard")
    (when arg
      (kill-region  (region-beginning) (region-end)))
    (deactivate-mark))))

(defun my-cut-to-xclipboard()
  (interactive)
  (my-copy-to-xclipboard t))

(defun my-paste-from-xclipboard()
  (interactive)
  (if (display-graphic-p)
      (clipboard-yank)
    (insert (shell-command-to-string "xsel -o -b"))))

(global-set-key (kbd "C-c C-w") 'my-cut-to-xclipboard)
(global-set-key (kbd "C-c M-w") 'my-copy-to-xclipboard)
(global-set-key (kbd "C-c C-y") 'my-paste-from-xclipboard)
#+END_SRC
*** stretch-cursor
Non-nil means draw block cursor as wide as the glyph under it.
For example, if a block cursor is over a tab, it will be drawn as
wide as that tab on the display.
#+BEGIN_SRC emacs-lisp
(setq x-stretch-cursor t)
#+END_SRC
*** Show-Paren-Mode
show-paren-mode allows one to see matching pairs of parentheses and
other characters.  When point is on the opening character of one of
the paired characters, the other is highlighted.  When the point is
after the closing character of one of the paired characters, the other
is highlighted.
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC

** Keyboard Shortcuts

#+BEGIN_SRC emacs-lisp
;; Global Keyboard Shortcuts
;; Set help to C-?
(global-set-key (kbd "C-?") 'help-command)
;; Set mark paragraph to M-?
(global-set-key (kbd "M-?") 'mark-paragraph)
;; Set backspace to C-h
(global-set-key (kbd "C-h") 'delete-backward-char)
;; Set backspace word to M-h
(global-set-key (kbd "M-h") 'backward-kill-word)
;; Use meta+tab word completion
(global-set-key (kbd "M-TAB") 'dabbrev-expand)
;; Easy undo key
(global-set-key (kbd "C-/") 'undo)
;; Comment or uncomment the region
(global-set-key (kbd "C-c ;") 'comment-or-uncomment-region)
#+END_SRC
** Appearance
   Configuration related to the appearance of Emacs
*** Current line highlighting
    Highlights the current line of the point.
    Just helps to visualise where you are in the buffer.
    I turn it on globally, but explicitly turn it off where I don't deem it necessary.
    #+begin_src emacs-lisp
    (global-hl-line-mode t)

    (make-variable-buffer-local 'global-hl-line-mode)
    (defvar my-ghd-modes '(
                           shell-mode-hook
                           git-commit-mode-hook
                           term-mode-hook
                          )
      "Modes to ensure global-hl-line-mode is disabled for.")
      (dolist (m my-ghd-modes)
	(add-hook m (lambda () (setq global-hl-line-mode nil))))
    #+end_src
*** Rainbow Delimiters
    So handy! This will colourize delimiters differently based on their depth.
    Really helps you not get burried when you're in deep.
    #+begin_src emacs-lisp
    (use-package rainbow-delimiters
      :hook
      (prog-mode . rainbow-delimiters-mode)
      (yaml-mode . rainbow-delimiters-mode))
    #+end_src
*** Theme
/Fashion First!/
Needs =xprop= to switch between dark and light gnome bar theme
#+begin_src emacs-lisp
  (use-package
   doom-themes
   :if window-system
   :config
   (defadvice load-theme (before theme-dont-propagate activate)
     (mapc #'disable-theme custom-enabled-themes))
   (defun doom-theming (theme-name)
     (progn
       (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
             doom-themes-enable-italic t) ; if nil, italics is universally disabled
       (load-theme theme-name t)
       (doom-themes-visual-bell-config)
       (doom-themes-neotree-config)
       (doom-themes-treemacs-config)
       (doom-themes-org-config)))

   ;; https://www.emacswiki.org/emacs/frame-fns.el
   (defun get-frame-name (&optional frame)
     "Return the string that names FRAME (a frame).  Default is selected frame."
     (unless frame (setq frame  (selected-frame)))
     (if (framep frame)
         (cdr (assq 'name (frame-parameters frame)))
       (error "Function `get-frame-name': Argument not a frame: `%s'" frame)))

   ;; from https://nicolas.petton.fr/blog/emacs-dark-window-decoration.html
   (defun shade-frame-gnome (shade)
     (let ((frame-name (get-frame-name (selected-frame))))
       (call-process-shell-command
        (concat "xprop -f _GTK_THEME_VARIANT 8u -set _GTK_THEME_VARIANT \""
                shade "\" -name \""
                frame-name
                "\""))))

   (defun light () (interactive) (progn
                                   (doom-theming 'doom-one-light)
                                   (shade-frame-gnome "light")))
   (defun dark () (interactive) (progn
                                  (doom-theming 'doom-one)
                                  (shade-frame-gnome "dark")))
   (light))
#+end_src
*** Modeline
We use telephone-line because, it's fast to load.
Config coming later
#+BEGIN_SRC emacs-lisp
    (use-package telephone-line
      :config (progn
		(setq telephone-line-lhs
		      '((evil   . (telephone-line-evil-tag-segment))
			(accent . (telephone-line-vc-segment
				   telephone-line-erc-modified-channels-segment
				   telephone-line-process-segment))
			(nil    . (telephone-line-minor-mode-segment
				   telephone-line-buffer-segment))))
		(setq telephone-line-rhs
		      '((nil    . (telephone-line-misc-info-segment))
			(accent . (telephone-line-major-mode-segment))
			(evil   . (telephone-line-airline-position-segment))))
		(telephone-line-mode 1)))
#+END_SRC
* Major modes
** PDF-tools
#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :defer t
    :mode ("\\.pdf\\'" . pdf-view-mode)
    :config (pdf-tools-install))
#+END_SRC

** Python
#+BEGIN_SRC emacs-lisp
  (setq-default python-indent 4)
  (setq-default python-indent-offset 4)
  (add-hook 'python-mode-hook
            (lambda ()
              (setq tab-width 4)))
  (setq-default pdb-command-name "python -m pdb")

  (use-package
    conda
    :commands conda-env-activate)
#+END_SRC
** Org-mode
General org-mode configuration

#+BEGIN_SRC emacs-lisp
    (use-package org-bullets
      :commands (org-bullets-mode)
      :init
      (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))

    (use-package org-download 
      :disabled t
      :after org
      :config
      (setq-default org-download-heading-lvl nil)
       ;;; to get rid of the #+DOWNLOADED part
      (setq-default org-download-image-dir "~/org/img/")
      (setq org-download-annotate-function (lambda (_) ""))
      (setq org-download-method 'attach)
      )

      ;; to make notes to pdf using org-mode
    (use-package org-noter
      :disabled t
      :config
      (setq-default org-noter-default-notes-file-names '("~/org/notes.org")
		    org-noter-hide-other t
		    org-noter))

  (use-package
   cdlatex
   :disabled t
   :ensure auctex
   :hook ((org-mode . turn-on-org-cdlatex)
	  (LaTeX-mode . turn-on-cdlatex)))

  (use-package
   ob-ipython
   :defer 1
   :config
   ;; don't prompt me to confirm everytime I want to evaluate a block
   (setq org-confirm-babel-evaluate nil)
   ;; display/update images in the buffer after I evaluate
   (add-hook 'org-babel-after-execute-hook
	     'org-display-inline-images 'append))

  ; stolen from https://github.com/jkitchin/scimax/blob/master/scimax-ob.el
  (defun sim/ob-clear-all-results ()
    "Clear all results in the buffer."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (while (org-babel-next-src-block)
	(org-babel-remove-result))))

  (defun sim/execute-to-point ()
    "Execute all the src blocks that start before point."
    (interactive)
    (let ((p (point)))
      (save-excursion
	(goto-char (point-min))
	(while (and (org-babel-next-src-block) (< (point) p))
	  (org-babel-execute-src-block)))))
#+END_SRC

* Minor Modes
** Flymake
#+BEGIN_SRC emacs-lisp
  (use-package flymake
    :diminish)
#+END_SRC
** Ivy

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :diminish
    :config
    (ivy-mode t)
    (setq ivy-use-virtual-buffers t)
    (setq enable-recursive-minibuffers t)
    (setq ivy-wrap t)
    (global-set-key (kbd "C-c C-r") 'ivy-resume)
    ;; Show #/total when scrolling buffers
    (setq ivy-count-format "%d/%d "))

  (use-package swiper
    :defer 1
    :bind (("C-s" . swiper)
           ("C-r" . swiper)))
#+END_SRC

** Avy

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :diminish
    :defer 1
    :bind
    (("C-;" . avy-goto-char)))
#+END_SRC

** [[https://github.com/magit/magit][Magit
]]
   The one true Git porcelain!
   Truely a joy to use - it surfaces the power of Git in such a fluent manner.
   Anyone using Git and Emacs *needs* Magit in their life!
   #+begin_src emacs-lisp
     (use-package
      magit
      :defer
      :bind ("C-c m" . magit-status)
      :init
      (setq magit-completing-read-function 'ivy-completing-read))
   #+end_src

** [[https://github.com/sigma/magit-gh-pulls][GitHub integration]]
   This package integrates Magit with GitHub to allow the user to perform pull request actions.
   I've added an argument so that when raising a new PR, it's automatically opened in my web-browser.
   If my web-browser is already running, this'll simply open a new tab - if not, it'll spawn a new instance.
   Another handy functionality here is that the URL of the PR is automatically copied to the kill ring, so you can
   paste it wherever necessary.
   #+begin_src emacs-lisp
   (use-package magit-gh-pulls
     :hook (magit-mode . turn-on-magit-gh-pulls)
     :bind (:map magit-gh-pulls-mode-map
     ("$" . magit-gh-pulls-popup)))
   #+end_src

** [[https://github.com/Fuco1/smartparens][Smartparens]]
   Brilliant automatic balancing of pairs. Makes for a really nice experience when typing in any language - programming or not.
   Just check out some of the gifs in the project's README.
   #+begin_src emacs-lisp
     (use-package smartparens
       :diminish smartparens-mode
       :config
       (progn
	 (smartparens-global-mode)
	 (show-smartparens-global-mode t)))
   #+end_src

** Yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package
   yasnippet
   :defer 3
   :diminish yas-minor-mode
   :config (yas-global-mode t))
#+END_SRC
** Company

   #+BEGIN_SRC emacs-lisp
     (use-package company
       :defer 3
       :diminish ""
       :init

       :bind (:map company-active-map
		   ("M-j" . company-select-next)
		   ("M-k" . company-select-previous))
       :preface
       ;; enable yasnippet everywhere
       (defvar company-mode/enable-yas t
	 "Enable yasnippet for all backends.")
       (defun company-mode/backend-with-yas (backend)
	 (if (or
	      (not company-mode/enable-yas)
	      (and (listp backend) (member 'company-yasnippet backend)))
	     backend
	   (append (if (consp backend) backend (list backend))
		   '(:with company-yasnippet))))
       :config
       (global-company-mode)
       (setq company-tooltip-limit 10)
       (setq company-dabbrev-downcase 0)
       (setq company-idle-delay 0)
       (setq company-echo-delay 0)
       (setq company-minimum-prefix-length 3)
       (setq company-require-match nil)
       (setq company-selection-wrap-around t)
       (setq company-tooltip-align-annotations t)
       ;; (setq company-tooltip-flip-when-above t)
       (setq company-transformers '(company-sort-by-occurrence)) ; weight by frequency
       (define-key company-active-map (kbd "M-n") nil)
       (define-key company-active-map (kbd "M-p") nil)
       (define-key company-active-map (kbd "C-n") 'company-select-next)
       (define-key company-active-map (kbd "C-p") 'company-select-previous)
       (define-key company-active-map (kbd "TAB") 'company-complete-common-or-cycle)
       (define-key company-active-map (kbd "<tab>") 'company-complete-common-or-cycle)
       (define-key company-active-map (kbd "S-TAB") 'company-select-previous)
       (define-key company-active-map (kbd "<backtab>") 'company-select-previous)
       (setq company-backends
	     (mapcar #'company-mode/backend-with-yas company-backends))

       (use-package company-statistics
	 :ensure t
	 :config
	 (add-hook 'after-init-hook 'company-statistics-mode)))
   #+END_SRC

** [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]
   Having multiple cursors can be very powerful.
   This allows you to perform simultaneous actions at multiple positions within the buffer.
   This can be based on arbitrary regions (n amount of lines, as chosen manually), for each ocurrance of a pattern/selection, etc.
   #+begin_src emacs-lisp
   (use-package multiple-cursors
     :bind
     ("C-S-c C-S-c" . mc/edit-lines)
     ("C->" . mc/mark-next-like-this)
     ("C-<" . mc/mark-previous-like-this)
     ("C-c C->" . mc/mark-all-like-this))
   #+end_src

** [[https://github.com/purcell/exec-path-from-shell][Set exec/man PATH from shell]]
   When looking for executables/man-pages, Emacs will inherit these properties from the OS environment.
   This package provides the ability to do so from the user's shell, where they may have some more complex logic to determine such paths.
   #+begin_src emacs-lisp
   (use-package exec-path-from-shell
     :config
     (setq exec-path-from-shell-check-startup-files nil)
     (exec-path-from-shell-initialize))
   #+end_src

** [[https://github.com/emacsfodder/move-text][MoveText]]
   Easily move text up and down.
   I've tied this into a little hydra for more natural repeated movement.
   #+begin_src emacs-lisp
   (use-package move-text
     :bind ("C-c t" . hydra-move-text/body)
     :config
     ;; Move Text
     (defhydra hydra-move-text ()
       "Move text"
       ("k" move-text-up "Up")
       ("j" move-text-down "Down")
       ("q" nil "Quit" :color blue)))
   #+end_src
** Eldoc
#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :defer 3
    :diminish)
#+END_SRC

** multi-term
#+BEGIN_SRC emacs-lisp
  (use-package multi-term
    :bind (("C-x m" . multi-term-next)
           ("C-x M" . multi-term))
    :config '(setq multi-term-program "/bin/zsh"))
#+END_SRC

** eglot
#+BEGIN_SRC emacs-lisp
  (use-package eglot
    :hook  (python-mode . eglot-ensure)
    :commands (eglot))
#+END_SRC

** dictcc
Dict.cc in Emacs
#+BEGIN_SRC emacs-lisp
(use-package dictcc
  :bind (("C-x RET ," . dictcc)
	 ("C-x RET ." . dictcc-at-point))
  :custom
  (dictcc-source-lang "de")
  (dictcc-destination-lang "en")
  (dictcc-completion-backend 'ivy))
#+END_SRC

** which-key
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :defer 3)
#+END_SRC

* Local Configuration

#+BEGIN_SRC emacs-lisp
  (let ((localel "~/.emacs.d/local.el"))
    (if (file-exists-p localel)
        (load (file-name-sans-extension localel))))
#+END_SRC
